#!/usr/bin/perl -w
use strict;
use Data::Dumper;
# This script can be used to start|stop the nc listening processes for every port listed in monitored_tcp or monitored_udp
# Please edit the arrays below to configure the monitored ports, ranges are acceptable e.g. 20-24 will expand to 20 21 22 23 24
# port 22 exluded in testing
my @monitored_tcp = qw (995 1194 1494 3128 3389 5900 8080);
my @monitored_udp = qw (1194 7000-7007);
#my @monitored_tcp = qw (21 22 80 110 143 220 389 406 443 465 587 636 993 995 1194 1494 3128 3389 5900 8080);
#my @monitored_udp = qw (123 1194 4500 5000-5110 7000-7007);

# run with either 'up' or 'down' as a parameter 
my $updown=shift;
my %monitored_all;

if (($updown) and ($updown eq 'up')) {
  &start;
} elsif (($updown) and ($updown eq 'down')) {
  &stop;
} else {
  print "Usage: 'lcontrol up' starts the eduprobe listening processes, 'lcontrol down' kills them\n";
  exit 0;
}


sub get_ports {
  my $proto = shift;
  my @array;
  if ($proto eq 'tcp') {
    @array = @monitored_tcp;
  } elsif ($proto eq 'udp') {
    @array = @monitored_udp;
  }
  foreach (@array) {
    if (($_ =~ /^(\d+)-(\d+)$/) and ($1 < $2)) {
      my $low = $1;
      my $high = $2;
      while ($low <= $high) {
	$monitored_all{$proto}{$low}++;
	$low++;
      }
    } elsif ($_ =~ /^\d+$/) {
      $monitored_all{$proto}{$_}++;
    } else {
      die "failed to parse configured port array at port $_";
    }
  }
}
  
sub start { 
  my $i = 0;
  &get_ports('tcp');
  &get_ports('udp');
  &check_used_ports;
  foreach my $proto (keys %monitored_all) {
    foreach my $port (keys %{$monitored_all{$proto}}) {
      if (system ("/bin/bash ./listener $proto $port &") == 0) {	# Doesn't work, the listener script returns 0 regardless ...
	$i++;
        print "started listener for $proto/$port\n";
      }
    }
  }
  if ($i > 0) {
    print "started $i processes\n";
  }
}

sub check_used_ports {
  my %inuse;
  my @openports = `/bin/netstat -nlp`;
  my $clash = 0;
  foreach (@openports) {
    if ($_ =~ /^(tcp|udp)\s+\d+\s+\d+\s+[\d\.]+:(\d+)/) {
      $inuse{$1}{$2}++;
    }
  }
  for my $upr (keys %inuse) {
    for my $cpr (keys %monitored_all) {
      if ($upr eq $cpr) {
	for my $upt (keys %{$inuse{$upr}}) {
	  for my $cpt (keys %{$monitored_all{$cpr}}) {
	    if ($upt eq $cpt) {
	      print "Port in use: $upr/$upt\n";
	      $clash = 1;
	    }
	  }
	}
      }
    }
  }
  if ($clash == 1) {
    print "\nOne or more ports are configured for monitoring but are already in use, aborting.\nRun lcontrol down to kill any preexisting instances of the eduprobe listener.\n";
  }
}

sub stop {
  my @ps = `/bin/ps aux`;
  my $i = 0;
  foreach (@ps) {
    if ($_ =~ /^\w+\s+([0-9]+).+?\/bin\/bash \.\/listener/) {
      my $pid = $1;
      $i++;
      print "killing $pid\n";
      system ("kill $pid");
    }
  }
  if ($i > 0) {
    print "killed $i processes\n";
  }
}
